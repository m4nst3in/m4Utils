package me.m4nst3in.m4Utils.listeners;

import me.m4nst3in.m4Utils.Main;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.entity.EntityPickupItemEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryDragEvent;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.event.player.PlayerEditBookEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BookMeta;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class ExploitItemBlocker implements Listener {
    private final Main plugin;
    private final Set<Material> blockedItems = new HashSet<>();
    private final String BYPASS_PERMISSION = "m4utils.exploitblocker.bypass";
    private static final String BLOCKED_ITEM_MESSAGE = "&c⚠ Este item está bloqueado devido a possíveis exploits.";
    private static final int MAX_BOOK_PAGE_LENGTH = 256; // Maximum sensible page length

    public ExploitItemBlocker(Main plugin) {
        this.plugin = plugin;

        // Add all potentially exploitable items
        blockedItems.addAll(Arrays.asList(
                Material.WRITABLE_BOOK,       // Book and Quill
                Material.WRITTEN_BOOK,        // Written Book
                Material.COMMAND_BLOCK,       // Command Block
                Material.CHAIN_COMMAND_BLOCK, // Chain Command Block
                Material.REPEATING_COMMAND_BLOCK, // Repeating Command Block
                Material.STRUCTURE_BLOCK,     // Structure Block
                Material.STRUCTURE_VOID,      // Structure Void
                Material.DEBUG_STICK,         // Debug Stick
                Material.KNOWLEDGE_BOOK,      // Knowledge Book
                Material.JIGSAW               // Jigsaw Block
        ));
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerInteract(PlayerInteractEvent event) {
        Player player = event.getPlayer();
        ItemStack item = event.getItem();

        // Check if player has bypass permission
        if (player.hasPermission(BYPASS_PERMISSION)) return;

        // Check if the item is null or not in blocked list
        if (item == null || !blockedItems.contains(item.getType())) return;

        // If interacting with a blocked item
        if (event.getAction() == Action.RIGHT_CLICK_AIR ||
                event.getAction() == Action.RIGHT_CLICK_BLOCK) {
            event.setCancelled(true);
            player.sendMessage(Main.colorize(BLOCKED_ITEM_MESSAGE));
        }
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onBookEdit(PlayerEditBookEvent event) {
        Player player = event.getPlayer();

        // Check if player has bypass permission
        if (player.hasPermission(BYPASS_PERMISSION)) return;

        BookMeta meta = event.getNewBookMeta();

        // Check for oversized book content
        boolean oversized = false;
        for (String page : meta.getPages()) {
            if (page.length() > MAX_BOOK_PAGE_LENGTH) {
                oversized = true;
                break;
            }
        }

        if (oversized) {
            event.setCancelled(true);
            player.sendMessage(Main.colorize(BLOCKED_ITEM_MESSAGE + " (Conteúdo muito grande)"));
        }
    }

    // Prevent picking up blocked items from the ground
    @EventHandler(priority = EventPriority.HIGH)
    public void onItemPickup(EntityPickupItemEvent event) {
        // Check if the entity picking up the item is a player
        if (!(event.getEntity() instanceof Player)) return;

        Player player = (Player) event.getEntity();

        // Check if player has bypass permission
        if (player.hasPermission(BYPASS_PERMISSION)) return;

        ItemStack item = event.getItem().getItemStack();

        // Check if the item is in the blocked list
        if (blockedItems.contains(item.getType())) {
            event.setCancelled(true);
            player.sendMessage(Main.colorize(BLOCKED_ITEM_MESSAGE));
        }
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onInventoryClick(InventoryClickEvent event) {
        if (!(event.getWhoClicked() instanceof Player)) return;

        Player player = (Player) event.getWhoClicked();
        if (player.hasPermission(BYPASS_PERMISSION)) return;

        // Check all possible items involved in the click
        ItemStack cursor = event.getCursor();
        ItemStack current = event.getCurrentItem();
        ItemStack hotbar = null;

        if (event.getHotbarButton() != -1) {
            hotbar = player.getInventory().getItem(event.getHotbarButton());
        }

        // Block any attempt to interact with blocked items in any inventory
        if ((cursor != null && blockedItems.contains(cursor.getType())) ||
                (current != null && blockedItems.contains(current.getType())) ||
                (hotbar != null && blockedItems.contains(hotbar.getType()))) {
            event.setCancelled(true);
            player.sendMessage(Main.colorize(BLOCKED_ITEM_MESSAGE));
        }
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onInventoryDrag(InventoryDragEvent event) {
        if (!(event.getWhoClicked() instanceof Player)) return;

        Player player = (Player) event.getWhoClicked();
        if (player.hasPermission(BYPASS_PERMISSION)) return;

        ItemStack item = event.getOldCursor();

        // Block any attempt to drag blocked items
        if (item != null && blockedItems.contains(item.getType())) {
            event.setCancelled(true);
            player.sendMessage(Main.colorize(BLOCKED_ITEM_MESSAGE));
        }
    }
}